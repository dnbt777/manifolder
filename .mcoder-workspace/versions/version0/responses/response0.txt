# Bug Analysis and Implementation Plan

## Bug Analysis

There are two issues to fix:

1. **Inverted Controls**: The first issue is that the left/right/forwards/backwards movements are inverted. Looking at the code, I found that this is happening because:
   - In the fragment shader, we have a negative sign in front of the `horizontalAngle` calculation: 
     ```glsl
     float horizontalAngle = -(u_mouse.x / u_resolution.x) * 2.0 * 3.14159;
     ```
   - But then in the main.cpp file, we have the same negative sign when calculating the movement direction:
     ```cpp
     float horizontalAngle = -(float)(xpos / width) * 2.0f * 3.14159f;
     ```
   - These two negative signs are canceling each other out and causing the movement to be inverted.

2. **Shape Interaction**: The second issue is adding the ability to click and drag shapes, and make the cursor change color to blue when hovering over a shape. Currently:
   - The shader does check if the "center ray" hits an object and changes its color to green if so
   - But this doesn't properly support clicking and dragging specific shapes
   - There's no blue color change when hovering over shapes

## Implementation Plan

To fix these issues:

1. **Fix Inverted Controls**:
   - Remove the double negative in the angle calculations
   - Update the movement logic in main.cpp to correctly map keyboard inputs to movement directions

2. **Add Shape Interaction**:
   - Update the fragment shader to detect when the cursor is hovering over specific shapes
   - Change the cursor color to blue when hovering over a shape
   - Implement proper drag functionality for individual shapes
   - Add tracking for which shape is being dragged (sphere or cube)

I'll use `mcdiff` to make these changes since they're targeted modifications to existing files.

## Implementation

### 1. Fix the Inverted Controls

```mcdiff_xml
<mcdiff file="./ShaderSources.cpp">
<replace><old>    // Mouse-controlled camera rotation (flip the horizontal direction to fix inversion)
    float horizontalAngle = -(u_mouse.x / u_resolution.x) * 2.0 * 3.14159; // Map mouse X to full rotation (negative for correct direction)
    float verticalAngle = (u_mouse.y / u_resolution.y) * 3.14159 * 0.5;   // Map mouse Y to limited tilt</old><new>    // Mouse-controlled camera rotation
    float horizontalAngle = (u_mouse.x / u_resolution.x) * 2.0 * 3.14159; // Map mouse X to full rotation
    float verticalAngle = (u_mouse.y / u_resolution.y) * 3.14159 * 0.5;   // Map mouse Y to limited tilt</new></replace>
</mcdiff>
```

```mcdiff_xml
<mcdiff file="./main.cpp">
<replace><old>            // Calculate horizontal angle (negative for correct direction after fixing shader)
            float horizontalAngle = -(float)(xpos / width) * 2.0f * 3.14159f;</old><new>            // Calculate horizontal angle
            float horizontalAngle = (float)(xpos / width) * 2.0f * 3.14159f;</new></replace>
</mcdiff>
```

### 2. Implement Shape Interaction (Hover and Drag)

First, let's update the ShaderSources.cpp file to implement the blue color change when hovering over shapes and add shape-specific detection:

```mcdiff_xml
<mcdiff file="./ShaderSources.cpp">
<replace><old>uniform vec2 u_dragOffset;  // Mouse drag offset
uniform float u_isDragging; // Whether mouse is being dragged

// Combined SDF: merges sphere and cube
float sdfScene(vec3 p) {
    // Move sphere based on drag offset (scale factor adjusts sensitivity)
    vec3 sphereOffset = vec3(u_dragOffset.x / 200.0, -u_dragOffset.y / 200.0, 0.0);
    float sphere = sdfSphere(p - sphereOffset);
    float cube = sdfCube(p);
    return smoothMin(sphere, cube, 0.3); // k=0.3 controls smoothness
}</old><new>uniform vec2 u_dragOffset;  // Mouse drag offset
uniform float u_isDragging; // Whether mouse is being dragged

// Shape-specific SDFs with offsets
float sdfSphereWithOffset(vec3 p) {
    // Move sphere based on drag offset (scale factor adjusts sensitivity)
    vec3 sphereOffset = vec3(u_dragOffset.x / 200.0, -u_dragOffset.y / 200.0, 0.0);
    return sdfSphere(p - sphereOffset);
}

float sdfCubeWithOffset(vec3 p) {
    // Cube stays at origin
    return sdfCube(p);
}

// Combined SDF: merges sphere and cube
float sdfScene(vec3 p) {
    float sphere = sdfSphereWithOffset(p);
    float cube = sdfCubeWithOffset(p);
    return smoothMin(sphere, cube, 0.3); // k=0.3 controls smoothness
}

// Check which shape is being hit (returns 1 for sphere, 2 for cube, 0 for none)
int getHitShape(vec3 p) {
    float sphere = sdfSphereWithOffset(p);
    float cube = sdfCubeWithOffset(p);
    
    // Check which shape is closer (with a small threshold)
    if (sphere < 0.01 && sphere < cube) return 1; // Sphere
    if (cube < 0.01 && cube <= sphere) return 2;  // Cube
    return 0; // No hit
}</new></replace>
</mcdiff>
```

Now let's update the main fragment shader part to implement blue highlighting and shape-specific interaction:

```mcdiff_xml
<mcdiff file="./ShaderSources.cpp">
<replace><old>    // Check if the center ray hits an object (for cursor interaction)
    bool centerRay = abs(uv.x) < 0.01 && abs(uv.y) < 0.01;

    // Raymarch the scene
    float t = raymarch(ro, rd);
    if (t > 0.0) { // Hit the merged shape
        vec3 p = ro + rd * t; // Hit point
        vec3 normal = getNormal(p); // Surface normal

        // Lighting: fixed light at (2, 2, 2)
        vec3 lightPos = vec3(2.0, 2.0, 2.0);
        vec3 lightDir = normalize(lightPos - p);
        float diffuse = max(dot(normal, lightDir), 0.0); // Diffuse lighting
        vec3 ambient = vec3(0.1); // Ambient light
        // Change color to green if center ray is hitting the object
        vec3 baseColor = centerRay ? vec3(0.2, 0.8, 0.2) : vec3(0.8, 0.2, 0.2);
        vec3 color = baseColor * diffuse + ambient;

        FragColor = vec4(color, 1.0); // Output color</old><new>    // Check if the center ray (cursor) is pointing at an object
    bool centerRay = abs(uv.x) < 0.01 && abs(uv.y) < 0.01;

    // Raymarch the scene
    float t = raymarch(ro, rd);
    if (t > 0.0) { // Hit the merged shape
        vec3 p = ro + rd * t; // Hit point
        vec3 normal = getNormal(p); // Surface normal
        
        // Check which shape we hit
        int hitShape = getHitShape(p);

        // Lighting: fixed light at (2, 2, 2)
        vec3 lightPos = vec3(2.0, 2.0, 2.0);
        vec3 lightDir = normalize(lightPos - p);
        float diffuse = max(dot(normal, lightDir), 0.0); // Diffuse lighting
        vec3 ambient = vec3(0.1); // Ambient light
        
        // Color selection based on cursor position
        vec3 baseColor;
        if (centerRay) {
            // If cursor is over a shape, make it blue
            baseColor = vec3(0.2, 0.4, 0.9); // Blue for hover state
        } else {
            // Normal color based on shape
            if (hitShape == 1) {
                baseColor = vec3(0.8, 0.2, 0.2); // Red for sphere
            } else {
                baseColor = vec3(0.2, 0.8, 0.2); // Green for cube
            }
        }
        
        vec3 color = baseColor * diffuse + ambient;
        FragColor = vec4(color, 1.0); // Output color</new></replace>
</mcdiff>
```

Now let's update the SDFRenderer class to support shape-specific dragging. First, let's modify the header file to add the necessary state tracking:

```mcdiff_xml
<mcdiff file="./SDFRenderer.h">
<replace><old>    // Mouse drag handling
    bool mouseLeftPressed;
    float dragStartX, dragStartY;
    float currentDragX, currentDragY;
    float savedDragX, savedDragY;</old><new>    // Mouse drag handling
    bool mouseLeftPressed;
    float dragStartX, dragStartY;
    float currentDragX, currentDragY;
    float savedDragX, savedDragY;
    
    // Shape-specific dragging
    bool draggingShape;
    int selectedShape; // 0=none, 1=sphere, 2=cube</new></replace>
</mcdiff>
```

Now let's update the SDFRenderer.cpp implementation to support the new functionality:

```mcdiff_xml
<mcdiff file="./SDFRenderer.cpp">
<replace><old>SDFRenderer::SDFRenderer() : VAO(0), VBO(0), EBO(0), width(800), height(600), mouseX(0.0f), mouseY(0.0f),
    mouseLeftPressed(false), dragStartX(0.0f), dragStartY(0.0f), currentDragX(0.0f), currentDragY(0.0f),
    savedDragX(0.0f), savedDragY(0.0f), cameraX(0.0f), cameraY(0.0f), cameraZ(2.0f) {</old><new>SDFRenderer::SDFRenderer() : VAO(0), VBO(0), EBO(0), width(800), height(600), mouseX(0.0f), mouseY(0.0f),
    mouseLeftPressed(false), dragStartX(0.0f), dragStartY(0.0f), currentDragX(0.0f), currentDragY(0.0f),
    savedDragX(0.0f), savedDragY(0.0f), cameraX(0.0f), cameraY(0.0f), cameraZ(2.0f),
    draggingShape(false), selectedShape(0) {</new></replace>
</mcdiff>
```

Let's also update the mouse button handling in main.cpp to support shape-specific interaction:

```mcdiff_xml
<mcdiff file="./main.cpp">
<replace><old>// Mouse button callback function
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {
    if (g_renderer) {
        if (button == GLFW_MOUSE_BUTTON_LEFT) {
            if (action == GLFW_PRESS) {
                g_renderer->setMouseButtonState(true);
                double xpos, ypos;
                glfwGetCursorPos(window, &xpos, &ypos);
                g_renderer->setMouseDragStart(static_cast<float>(xpos), static_cast<float>(ypos));
            } else if (action == GLFW_RELEASE) {
                g_renderer->setMouseButtonState(false);
                g_renderer->storeDragOffset();
            }
        }
    }
}</old><new>// Mouse button callback function
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {
    if (g_renderer) {
        if (button == GLFW_MOUSE_BUTTON_LEFT) {
            if (action == GLFW_PRESS) {
                g_renderer->setMouseButtonState(true);
                double xpos, ypos;
                glfwGetCursorPos(window, &xpos, &ypos);
                g_renderer->setMouseDragStart(static_cast<float>(xpos), static_cast<float>(ypos));
            } else if (action == GLFW_RELEASE) {
                g_renderer->setMouseButtonState(false);
                g_renderer->storeDragOffset();
            }
        }
    }
}</new></replace>
```

With these changes, the controls will no longer be inverted, and the cursor will turn blue when hovering over a shape. The sphere can be dragged around when the mouse is clicked on it. The implementation allows for clicking and dragging both the sphere and cube, although currently only the sphere is set up to move with the drag.