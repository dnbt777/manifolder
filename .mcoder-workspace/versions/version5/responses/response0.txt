# Implementation Plan: Making the Ball Draggable

The current implementation already has a dragging system, but it's tied to the ball's position in the scene. The ball moves with a drag offset calculated from mouse movements, but the behavior we want to implement is to let users drag the ball freely around the scene and have it stay where they placed it, even while they move the camera using WASD controls.

## Current Behavior
1. The ball (sphere) responds to dragging with the mouse, but its position is tied to camera movement.
2. The drag offset is calculated and applied in the fragment shader.
3. Movement is controlled through the mouseLeftPressed boolean and a drag offset system.

## Bug Analysis
This isn't exactly a bug but a feature change. The current implementation uses the mouse position and drag offset to move the sphere, but the sphere's position is recalculated in every frame and doesn't stay independent of the camera. We need to change this so the sphere's position is fixed in world space once the user places it.

## Implementation Plan

1. **Modify the SDFRenderer Class**:
   - Add an explicit sphere position variable that will track the sphere's position in world space
   - Keep the drag functionality, but use it to update this world-space position
   - Make sure the ball stays where left when camera moves

2. **Update the ShaderSources**:
   - Change the fragment shader to use the sphere's world position (passed as a uniform) instead of calculating position from drag offset
   - Keep the drag detection to select the sphere but modify how position is calculated

3. **Implement Changes**:
   - Add new uniform variables for the sphere's world position
   - Update the mouse dragging logic to modify the sphere's world position
   - Ensure the sphere stays at its world position regardless of camera movement

Let's implement these changes:

## Implementation

```mcdiff_xml
<mcdiff file="SDFRenderer.h">
<replace><old>    // Shape-specific dragging
    bool draggingShape;
    int selectedShape; // 0=none, 1=sphere, 2=cube</old><new>    // Shape-specific dragging
    bool draggingShape;
    int selectedShape; // 0=none, 1=sphere, 2=cube
    
    // World position of the sphere
    float sphereX, sphereY, sphereZ;</new></replace>
</mcdiff>
```

```mcdiff_xml
<mcdiff file="SDFRenderer.cpp">
<replace><old>SDFRenderer::SDFRenderer() : VAO(0), VBO(0), EBO(0), width(800), height(600), mouseX(0.0f), mouseY(0.0f),
    mouseLeftPressed(false), dragStartX(0.0f), dragStartY(0.0f), currentDragX(0.0f), currentDragY(0.0f),
    savedDragX(0.0f), savedDragY(0.0f), cameraX(0.0f), cameraY(0.0f), cameraZ(2.0f),
    draggingShape(false), selectedShape(0) {</old><new>SDFRenderer::SDFRenderer() : VAO(0), VBO(0), EBO(0), width(800), height(600), mouseX(0.0f), mouseY(0.0f),
    mouseLeftPressed(false), dragStartX(0.0f), dragStartY(0.0f), currentDragX(0.0f), currentDragY(0.0f),
    savedDragX(0.0f), savedDragY(0.0f), cameraX(0.0f), cameraY(0.0f), cameraZ(2.0f),
    draggingShape(false), selectedShape(0), sphereX(0.0f), sphereY(0.0f), sphereZ(0.0f) {</new></replace>
</mcdiff>
```

```mcdiff_xml
<mcdiff file="SDFRenderer.cpp">
<replace><old>void SDFRenderer::render(float time) {
    // Use shader
    shader.use();
    
    // Calculate drag offset if mouse is pressed
    if (mouseLeftPressed) {
        currentDragX = mouseX - dragStartX;
        currentDragY = mouseY - dragStartY;
    }
    
    // Set uniforms
    shader.setVec2("u_resolution", static_cast<float>(width), static_cast<float>(height));
    shader.setFloat("u_time", time);
    shader.setVec2("u_mouse", mouseX, mouseY);
    shader.setVec2("u_dragOffset", savedDragX + currentDragX, savedDragY + currentDragY);
    shader.setFloat("u_isDragging", mouseLeftPressed ? 1.0f : 0.0f);
    
    // Set camera position uniform
    shader.setVec3("u_cameraPos", cameraX, cameraY, cameraZ);
    
    // Draw quad
    glBindVertexArray(VAO);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
}</old><new>void SDFRenderer::render(float time) {
    // Use shader
    shader.use();
    
    // Calculate drag offset if mouse is pressed and update sphere position
    if (mouseLeftPressed) {
        currentDragX = mouseX - dragStartX;
        currentDragY = mouseY - dragStartY;
        
        // Convert mouse movement to world space movement
        // This is simplified - in a real implementation we'd use ray casting from mouse to world
        float horizontalAngle = -(mouseX / static_cast<float>(width)) * 2.0f * 3.14159f;
        
        // Get right and forward vectors based on camera orientation
        float rightX = -cos(horizontalAngle);
        float rightZ = sin(horizontalAngle);
        float forwardX = sin(horizontalAngle);
        float forwardZ = cos(horizontalAngle);
        
        // Scale factors to convert screen drag to world coordinates
        float dragScale = 0.005f;
        
        // Update the sphere position based on drag direction and camera orientation
        sphereX += (currentDragX * rightX - currentDragY * forwardX) * dragScale;
        sphereY += currentDragY * dragScale; // Y stays relative to screen
        sphereZ += (currentDragX * rightZ - currentDragY * forwardZ) * dragScale;
        
        // Reset the current drag for next frame
        dragStartX = mouseX;
        dragStartY = mouseY;
        currentDragX = currentDragY = 0.0f;
    }
    
    // Set uniforms
    shader.setVec2("u_resolution", static_cast<float>(width), static_cast<float>(height));
    shader.setFloat("u_time", time);
    shader.setVec2("u_mouse", mouseX, mouseY);
    shader.setVec3("u_spherePosition", sphereX, sphereY, sphereZ);
    shader.setFloat("u_isDragging", mouseLeftPressed ? 1.0f : 0.0f);
    
    // Set camera position uniform
    shader.setVec3("u_cameraPos", cameraX, cameraY, cameraZ);
    
    // Draw quad
    glBindVertexArray(VAO);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
}</new></replace>
</mcdiff>
```

```mcdiff_xml
<mcdiff file="SDFRenderer.cpp">
<replace><old>void SDFRenderer::storeDragOffset() {
    // Save current drag as permanent offset
    savedDragX += currentDragX;
    savedDragY += currentDragY;
    currentDragX = currentDragY = 0.0f;
}</old><new>void SDFRenderer::storeDragOffset() {
    // With the new implementation, we don't need to store drag offset separately
    // as the sphere's position is directly updated during dragging
    currentDragX = currentDragY = 0.0f;
}</new></replace>
</mcdiff>
```

Now let's update the fragment shader to use the sphere's world position:

```mcdiff_xml
<mcdiff file="ShaderSources.cpp">
<replace><old>// Fragment Shader: Renders merged sphere and cube with lighting
const char* fragmentShaderSource = R"(
#version 330 core
out vec4 FragColor;
uniform vec2 u_resolution; // Window size (e.g., 800x600)
uniform float u_time;      // Time for camera rotation
uniform vec2 u_mouse;      // Mouse position in screen coordinates
uniform vec3 u_cameraPos;  // Camera position in 3D space

// SDF for a sphere: distance to a sphere of radius 0.5
float sdfSphere(vec3 p) {
    return length(p) - 0.5;
}

// SDF for a cube: distance to a cube with side length 1.0
float sdfCube(vec3 p) {
    vec3 d = abs(p) - vec3(0.5); // Half-size of cube is 0.5
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}

// Smooth minimum: blends two distances smoothly
float smoothMin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

uniform vec2 u_dragOffset;  // Mouse drag offset
uniform float u_isDragging; // Whether mouse is being dragged

// Shape-specific SDFs with offsets
float sdfSphereWithOffset(vec3 p) {
    // Move sphere based on drag offset (scale factor adjusts sensitivity)
    vec3 sphereOffset = vec3(u_dragOffset.x / 200.0, -u_dragOffset.y / 200.0, 0.0);
    return sdfSphere(p - sphereOffset);
}

float sdfCubeWithOffset(vec3 p) {
    // Cube stays at origin
    return sdfCube(p);
}

// Combined SDF: merges sphere and cube
float sdfScene(vec3 p) {
    float sphere = sdfSphereWithOffset(p);
    float cube = sdfCubeWithOffset(p);
    return smoothMin(sphere, cube, 0.3); // k=0.3 controls smoothness
}

// Check which shape is being hit (returns 1 for sphere, 2 for cube, 0 for none)
int getHitShape(vec3 p) {
    float sphere = sdfSphereWithOffset(p);
    float cube = sdfCubeWithOffset(p);
    
    // Check which shape is closer (with a small threshold)
    if (sphere < 0.01 && sphere < cube) return 1; // Sphere
    if (cube < 0.01 && cube <= sphere) return 2;  // Cube
    return 0; // No hit
}</old><new>// Fragment Shader: Renders merged sphere and cube with lighting
const char* fragmentShaderSource = R"(
#version 330 core
out vec4 FragColor;
uniform vec2 u_resolution; // Window size (e.g., 800x600)
uniform float u_time;      // Time for camera rotation
uniform vec2 u_mouse;      // Mouse position in screen coordinates
uniform vec3 u_cameraPos;  // Camera position in 3D space
uniform vec3 u_spherePosition; // World position of the sphere

// SDF for a sphere: distance to a sphere of radius 0.5
float sdfSphere(vec3 p) {
    return length(p) - 0.5;
}

// SDF for a cube: distance to a cube with side length 1.0
float sdfCube(vec3 p) {
    vec3 d = abs(p) - vec3(0.5); // Half-size of cube is 0.5
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}

// Smooth minimum: blends two distances smoothly
float smoothMin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

uniform float u_isDragging; // Whether mouse is being dragged

// Shape-specific SDFs with world position
float sdfSphereWithPosition(vec3 p) {
    // Move sphere based on its world position
    return sdfSphere(p - u_spherePosition);
}

float sdfCubeWithOffset(vec3 p) {
    // Cube stays at origin
    return sdfCube(p);
}

// Combined SDF: merges sphere and cube
float sdfScene(vec3 p) {
    float sphere = sdfSphereWithPosition(p);
    float cube = sdfCubeWithOffset(p);
    return smoothMin(sphere, cube, 0.3); // k=0.3 controls smoothness
}

// Check which shape is being hit (returns 1 for sphere, 2 for cube, 0 for none)
int getHitShape(vec3 p) {
    float sphere = sdfSphereWithPosition(p);
    float cube = sdfCubeWithOffset(p);
    
    // Check which shape is closer (with a small threshold)
    if (sphere < 0.01 && sphere < cube) return 1; // Sphere
    if (cube < 0.01 && cube <= sphere) return 2;  // Cube
    return 0; // No hit
}</new></replace>
</mcdiff>
```

Let's update the mouse button callback in main.cpp to work better with our new dragging system:

```mcdiff_xml
<mcdiff file="main.cpp">
<replace><old>// Mouse button callback function
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {
    if (g_renderer) {
        if (button == GLFW_MOUSE_BUTTON_LEFT) {
            if (action == GLFW_PRESS) {
                g_renderer->setMouseButtonState(true);
                double xpos, ypos;
                glfwGetCursorPos(window, &xpos, &ypos);
                g_renderer->setMouseDragStart(static_cast<float>(xpos), static_cast<float>(ypos));
            } else if (action == GLFW_RELEASE) {
                g_renderer->setMouseButtonState(false);
                g_renderer->storeDragOffset();
            }
        }
    }
}</old><new>// Mouse button callback function
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {
    if (g_renderer) {
        if (button == GLFW_MOUSE_BUTTON_LEFT) {
            if (action == GLFW_PRESS) {
                g_renderer->setMouseButtonState(true);
                double xpos, ypos;
                glfwGetCursorPos(window, &xpos, &ypos);
                g_renderer->setMouseDragStart(static_cast<float>(xpos), static_cast<float>(ypos));
            } else if (action == GLFW_RELEASE) {
                g_renderer->setMouseButtonState(false);
                // No need to call storeDragOffset() as we're updating sphere position directly
            }
        }
    }
}</new></replace>
</mcdiff>
```

With these changes, the sphere should now:
1. Be draggable using the mouse 
2. Stay in its world position when the camera moves with WASD controls
3. Allow dragging while moving with WASD keys

The implementation converts mouse movements to world space changes based on the camera's orientation, so the sphere moves in a way that feels natural to the user. The sphere's position is tracked separately from the drag offset, allowing it to maintain its world position regardless of camera movement.