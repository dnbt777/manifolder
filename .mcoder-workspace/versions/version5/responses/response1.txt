# Implementation Plan: Making the Ball Draggable

## Understanding the Bug/Current Behavior

Currently, the system allows mouse drag operations but is not properly implementing a way for the user to drag the sphere independently of camera movement. The sphere's position is determined by the mouse drag offset via the `u_dragOffset` uniform in the shader, but there are a few issues:

1. The sphere moves along with the camera as the user moves around using WASD
2. The sphere can't be positioned independently of the camera view
3. There is no mechanism for detecting when the user is specifically dragging the sphere vs. just moving the mouse

## Implementation Plan

To implement dragging functionality for the sphere that's independent of camera movement, I need to make these changes:

1. **Modify the shader** to:
   - Store the sphere's position in world space, not relative to the camera
   - Keep the sphere at its last position when not being dragged
   - Properly detect when the ray from the cursor hits the sphere for dragging

2. **Update the SDFRenderer class** to:
   - Add state to track whether the sphere is being dragged
   - Add a world-space position for the sphere
   - Convert mouse screen coordinates to world coordinates based on the camera position and view
   - Add logic to determine when the mouse click hits the sphere

3. **Modify input handling in main.cpp** to:
   - Allow sphere dragging during camera movement (WASD)
   - Keep the sphere in position when not dragging

Let's implement this solution:

## Implementation

### 1. First, I'll update the ShaderSources.cpp file to properly handle world-space positioning

```mcdiff_xml
<mcdiff file="./ShaderSources.cpp">
<replace><old>// SDF for a sphere: distance to a sphere of radius 0.5
float sdfSphere(vec3 p) {
    return length(p) - 0.5;
}</old><new>// SDF for a sphere: distance to a sphere of radius 0.5
float sdfSphere(vec3 p, vec3 center) {
    return length(p - center) - 0.5;
}</new></replace>

<replace><old>// Shape-specific SDFs with offsets
float sdfSphereWithOffset(vec3 p) {
    // Move sphere based on drag offset (scale factor adjusts sensitivity)
    vec3 sphereOffset = vec3(u_dragOffset.x / 200.0, -u_dragOffset.y / 200.0, 0.0);
    return sdfSphere(p - sphereOffset);
}

float sdfCubeWithOffset(vec3 p) {
    // Cube stays at origin
    return sdfCube(p);
}</old><new>uniform vec3 u_spherePosition; // Sphere position in world space

// Shape-specific SDFs with positions
float sdfSphereWithOffset(vec3 p) {
    // Use the sphere's world position
    return sdfSphere(p, u_spherePosition);
}

float sdfCubeWithOffset(vec3 p) {
    // Cube stays at origin
    return sdfCube(p);
}</new></replace>

<replace><old>// Check which shape is being hit (returns 1 for sphere, 2 for cube, 0 for none)
int getHitShape(vec3 p) {
    float sphere = sdfSphereWithOffset(p);
    float cube = sdfCubeWithOffset(p);
    
    // Check which shape is closer (with a small threshold)
    if (sphere < 0.01 && sphere < cube) return 1; // Sphere
    if (cube < 0.01 && cube <= sphere) return 2;  // Cube
    return 0; // No hit
}</old><new>// Check which shape is being hit (returns 1 for sphere, 2 for cube, 0 for none)
int getHitShape(vec3 p) {
    float sphere = sdfSphereWithOffset(p);
    float cube = sdfCubeWithOffset(p);
    
    // Check which shape is closer (with a small threshold)
    if (sphere < 0.01 && sphere < cube) return 1; // Sphere
    if (cube < 0.01 && cube <= sphere) return 2;  // Cube
    return 0; // No hit
}

// Get the distance to the sphere specifically (for mouse interaction)
float getDistanceToSphere(vec3 p) {
    return sdfSphere(p, u_spherePosition);
}</new></replace>
</mcdiff>

### 2. Next, I'll update the SDFRenderer.h file to add new properties for tracking sphere position and dragging state

```mcdiff_xml
<mcdiff file="./SDFRenderer.h">
<replace><old>class SDFRenderer {
public:
    // Constructor
    SDFRenderer();
    
    // Initialize the renderer
    bool initialize();
    
    // Render the scene with current time
    void render(float time);
    
    // Clean up resources
    void cleanup();
    
    // Destructor
    ~SDFRenderer();
    
    // Set mouse position (for interactive effects)
    void setMousePosition(float x, float y);
    
    // Update window size (for proper aspect ratio)
    void setWindowSize(int w, int h);

    // Set mouse button state (for tracking drag operations)
    void setMouseButtonState(bool pressed);
    
    // Set drag start position
    void setMouseDragStart(float x, float y);
    
    // Store current drag offset as permanent offset
    void storeDragOffset();
    
    // Camera movement methods
    void moveCamera(float dx, float dy, float dz);
    void setCameraPosition(float x, float y, float z);</old><new>class SDFRenderer {
public:
    // Constructor
    SDFRenderer();
    
    // Initialize the renderer
    bool initialize();
    
    // Render the scene with current time
    void render(float time);
    
    // Clean up resources
    void cleanup();
    
    // Destructor
    ~SDFRenderer();
    
    // Set mouse position (for interactive effects)
    void setMousePosition(float x, float y);
    
    // Update window size (for proper aspect ratio)
    void setWindowSize(int w, int h);

    // Set mouse button state (for tracking drag operations)
    void setMouseButtonState(bool pressed);
    
    // Set drag start position
    void setMouseDragStart(float x, float y);
    
    // Update dragging state based on current mouse position
    bool checkSphereHit();
    
    // Camera movement methods
    void moveCamera(float dx, float dy, float dz);
    void setCameraPosition(float x, float y, float z);
    
    // Get the ray direction based on mouse position
    glm::vec3 getRayDirection() const;</new></replace>

<replace><old>private:
    // OpenGL objects
    GLuint VAO, VBO, EBO;
    
    // Camera position in 3D space
    float cameraX, cameraY, cameraZ;
    
    // Shader program
    Shader shader;
    
    // Window dimensions
    int width, height;
    
    // Mouse position
    float mouseX, mouseY;
    
    // Mouse drag handling
    bool mouseLeftPressed;
    float dragStartX, dragStartY;
    float currentDragX, currentDragY;
    float savedDragX, savedDragY;
    
    // Shape-specific dragging
    bool draggingShape;
    int selectedShape; // 0=none, 1=sphere, 2=cube</old><new>private:
    // OpenGL objects
    GLuint VAO, VBO, EBO;
    
    // Camera position in 3D space
    float cameraX, cameraY, cameraZ;
    
    // Shader program
    Shader shader;
    
    // Window dimensions
    int width, height;
    
    // Mouse position
    float mouseX, mouseY;
    
    // Mouse drag handling
    bool mouseLeftPressed;
    float dragStartX, dragStartY;
    float lastMouseX, lastMouseY;
    
    // Sphere position in world space
    float sphereX, sphereY, sphereZ;
    
    // Ray-sphere intersection data
    glm::vec3 dragStartIntersection;
    
    // Shape-specific dragging
    bool draggingShape;
    int selectedShape; // 0=none, 1=sphere, 2=cube
    
    // Helper method to convert screen to world coordinates
    bool screenToWorld(float screenX, float screenY, glm::vec3& worldPos);
    
    // Helper method for ray-sphere intersection
    bool raySphereIntersect(const glm::vec3& rayOrigin, const glm::vec3& rayDir, 
                           const glm::vec3& sphereCenter, float sphereRadius,
                           float& t);</new></replace>
</mcdiff>

### 3. Now I'll update the SDFRenderer.cpp implementation to handle the sphere's position and dragging

```mcdiff_xml
<mcdiff file="./SDFRenderer.cpp">
<replace><old>#include "SDFRenderer.h"
#include "ShaderSources.h"
#include <iostream></old><new>#include "SDFRenderer.h"
#include "ShaderSources.h"
#include <iostream>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp></new></replace>

<replace><old>SDFRenderer::SDFRenderer() : VAO(0), VBO(0), EBO(0), width(800), height(600), mouseX(0.0f), mouseY(0.0f),
    mouseLeftPressed(false), dragStartX(0.0f), dragStartY(0.0f), currentDragX(0.0f), currentDragY(0.0f),
    savedDragX(0.0f), savedDragY(0.0f), cameraX(0.0f), cameraY(0.0f), cameraZ(2.0f),
    draggingShape(false), selectedShape(0) {
    // Initialize global camera position
    ::cameraX = 0.0f;
    ::cameraY = 0.0f;
    ::cameraZ = 2.0f;
    ::cameraSpeed = 0.1f;
}</old><new>SDFRenderer::SDFRenderer() : VAO(0), VBO(0), EBO(0), width(800), height(600), mouseX(0.0f), mouseY(0.0f),
    mouseLeftPressed(false), dragStartX(0.0f), dragStartY(0.0f), lastMouseX(0.0f), lastMouseY(0.0f),
    sphereX(0.0f), sphereY(0.0f), sphereZ(0.0f), cameraX(0.0f), cameraY(0.0f), cameraZ(2.0f),
    draggingShape(false), selectedShape(0) {
    // Initialize global camera position
    ::cameraX = 0.0f;
    ::cameraY = 0.0f;
    ::cameraZ = 2.0f;
    ::cameraSpeed = 0.1f;
}</new></replace>

<replace><old>void SDFRenderer::render(float time) {
    // Use shader
    shader.use();
    
    // Calculate drag offset if mouse is pressed
    if (mouseLeftPressed) {
        currentDragX = mouseX - dragStartX;
        currentDragY = mouseY - dragStartY;
    }
    
    // Set uniforms
    shader.setVec2("u_resolution", static_cast<float>(width), static_cast<float>(height));
    shader.setFloat("u_time", time);
    shader.setVec2("u_mouse", mouseX, mouseY);
    shader.setVec2("u_dragOffset", savedDragX + currentDragX, savedDragY + currentDragY);
    shader.setFloat("u_isDragging", mouseLeftPressed ? 1.0f : 0.0f);
    
    // Set camera position uniform
    shader.setVec3("u_cameraPos", cameraX, cameraY, cameraZ);
    
    // Draw quad
    glBindVertexArray(VAO);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
}</old><new>void SDFRenderer::render(float time) {
    // Use shader
    shader.use();
    
    // Update sphere position if dragging
    if (mouseLeftPressed && draggingShape && selectedShape == 1) {
        // Calculate mouse movement delta
        float deltaX = mouseX - lastMouseX;
        float deltaY = mouseY - lastMouseY;
        
        // Get ray direction
        glm::vec3 rayDir = getRayDirection();
        
        // Calculate horizontal and vertical axes for dragging in screen space
        glm::vec3 forward(sin(mouseX/width*6.28f), 0, cos(mouseX/width*6.28f));
        glm::vec3 right = glm::normalize(glm::cross(forward, glm::vec3(0, 1, 0)));
        glm::vec3 up = glm::vec3(0, 1, 0);
        
        // Scale factors for movement sensitivity (adjust as needed)
        float horizontalSensitivity = 0.01f;
        float verticalSensitivity = 0.01f;
        
        // Update sphere position based on mouse movement
        sphereX += right.x * deltaX * horizontalSensitivity;
        sphereY -= deltaY * verticalSensitivity; // Negative for natural control
        sphereZ += right.z * deltaX * horizontalSensitivity;
    }
    
    // Update last mouse position
    lastMouseX = mouseX;
    lastMouseY = mouseY;
    
    // Set uniforms
    shader.setVec2("u_resolution", static_cast<float>(width), static_cast<float>(height));
    shader.setFloat("u_time", time);
    shader.setVec2("u_mouse", mouseX, mouseY);
    shader.setVec3("u_spherePosition", sphereX, sphereY, sphereZ);
    shader.setFloat("u_isDragging", draggingShape ? 1.0f : 0.0f);
    
    // Set camera position uniform
    shader.setVec3("u_cameraPos", cameraX, cameraY, cameraZ);
    
    // Draw quad
    glBindVertexArray(VAO);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
}</new></replace>

<replace><old>void SDFRenderer::setMousePosition(float x, float y) {
    mouseX = x;
    mouseY = y;
}</old><new>void SDFRenderer::setMousePosition(float x, float y) {
    mouseX = x;
    mouseY = y;
}</new></replace>

<replace><old>void SDFRenderer::setMouseButtonState(bool pressed) {
    mouseLeftPressed = pressed;
    if (!pressed) {
        currentDragX = currentDragY = 0.0f;
    }
}</old><new>void SDFRenderer::setMouseButtonState(bool pressed) {
    mouseLeftPressed = pressed;
    
    if (pressed) {
        // When button is pressed, check if we're hitting the sphere
        draggingShape = checkSphereHit();
        selectedShape = draggingShape ? 1 : 0;
    } else {
        // When released, stop dragging
        draggingShape = false;
        selectedShape = 0;
    }
}</new></replace>

<replace><old>void SDFRenderer::setMouseDragStart(float x, float y) {
    dragStartX = x;
    dragStartY = y;
    currentDragX = currentDragY = 0.0f;
}</old><new>void SDFRenderer::setMouseDragStart(float x, float y) {
    dragStartX = x;
    dragStartY = y;
    lastMouseX = x;
    lastMouseY = y;
}</new></replace>

<replace><old>void SDFRenderer::storeDragOffset() {
    // Save current drag as permanent offset
    savedDragX += currentDragX;
    savedDragY += currentDragY;
    currentDragX = currentDragY = 0.0f;
}</old><new>bool SDFRenderer::checkSphereHit() {
    // Get ray direction from camera through mouse position
    glm::vec3 rayDir = getRayDirection();
    glm::vec3 rayOrigin(cameraX, cameraY, cameraZ);
    glm::vec3 sphereCenter(sphereX, sphereY, sphereZ);
    
    // Check for ray-sphere intersection
    float t;
    if (raySphereIntersect(rayOrigin, rayDir, sphereCenter, 0.5f, t)) {
        return true;
    }
    return false;
}

glm::vec3 SDFRenderer::getRayDirection() const {
    // Convert mouse position to normalized device coordinates
    float ndcX = (2.0f * mouseX / width) - 1.0f;
    float ndcY = 1.0f - (2.0f * mouseY / height); // Flip Y for OpenGL
    
    // Calculate horizontal angle from mouse X position
    float horizontalAngle = -(mouseX / width) * 2.0f * 3.14159f;
    float verticalAngle = ((1.0f - mouseY / height) - 0.5f) * 3.14159f * 0.5f;
    
    // Calculate view direction
    glm::vec3 lookDir = glm::normalize(glm::vec3(
        sin(horizontalAngle) * cos(verticalAngle),
        sin(verticalAngle),
        cos(horizontalAngle) * cos(verticalAngle)
    ));
    
    // Calculate camera basis vectors
    glm::vec3 forward = lookDir;
    glm::vec3 right = glm::normalize(glm::cross(forward, glm::vec3(0.0f, 1.0f, 0.0f)));
    glm::vec3 up = glm::normalize(glm::cross(right, forward));
    
    // Aspect ratio correction
    float aspectRatio = static_cast<float>(width) / static_cast<float>(height);
    float ndcXAspect = ndcX * aspectRatio;
    
    // Ray direction with perspective
    return glm::normalize(forward + ndcXAspect * right + ndcY * up);
}

bool SDFRenderer::raySphereIntersect(const glm::vec3& rayOrigin, const glm::vec3& rayDir, 
                                    const glm::vec3& sphereCenter, float sphereRadius,
                                    float& t) {
    // Calculate coefficients for quadratic equation
    glm::vec3 oc = rayOrigin - sphereCenter;
    float a = glm::dot(rayDir, rayDir);
    float b = 2.0f * glm::dot(oc, rayDir);
    float c = glm::dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b * b - 4 * a * c;
    
    if (discriminant < 0) {
        // No intersection
        return false;
    }
    
    // Calculate nearest intersection point
    float t0 = (-b - sqrt(discriminant)) / (2.0f * a);
    float t1 = (-b + sqrt(discriminant)) / (2.0f * a);
    
    // Get the closest positive intersection
    if (t0 > 0) {
        t = t0;
    } else if (t1 > 0) {
        t = t1;
    } else {
        // Both intersections are behind the ray origin
        return false;
    }
    
    return true;
}</new></replace>
</mcdiff>

### 4. Finally, let's update the main.cpp to manage user input and coordinate with the sphere dragging

```mcdiff_xml
<mcdiff file="./main.cpp">
<replace><old>        // Mouse button callback function
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {
    if (g_renderer) {
        if (button == GLFW_MOUSE_BUTTON_LEFT) {
            if (action == GLFW_PRESS) {
                g_renderer->setMouseButtonState(true);
                double xpos, ypos;
                glfwGetCursorPos(window, &xpos, &ypos);
                g_renderer->setMouseDragStart(static_cast<float>(xpos), static_cast<float>(ypos));
            } else if (action == GLFW_RELEASE) {
                g_renderer->setMouseButtonState(false);
                g_renderer->storeDragOffset();
            }
        }
    }
}</old><new>        // Mouse button callback function
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {
    if (g_renderer) {
        if (button == GLFW_MOUSE_BUTTON_LEFT) {
            if (action == GLFW_PRESS) {
                double xpos, ypos;
                glfwGetCursorPos(window, &xpos, &ypos);
                g_renderer->setMouseDragStart(static_cast<float>(xpos), static_cast<float>(ypos));
                g_renderer->setMouseButtonState(true);
            } else if (action == GLFW_RELEASE) {
                g_renderer->setMouseButtonState(false);
            }
        }
    }
}</new></replace>

<replace><old>    // Lock cursor to window
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</old><new>    // Allow cursor to move freely
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);</new></replace>
</mcdiff>

## Summary of Changes

1. **Added world-space positioning for the sphere**:
   - Created a proper `u_spherePosition` uniform in the shader
   - Added sphere position tracking in the SDFRenderer class
   - Modified the SDF functions to account for sphere position

2. **Implemented dragging functionality**:
   - Added ray-sphere intersection to detect when the user is clicking on the sphere
   - Added tracking for drag state to determine if the sphere should move
   - Modified the rendering loop to update the sphere position based on mouse movement

3. **Fixed input handling**:
   - Changed cursor behavior to be visible rather than locked
   - Updated the mouse button callback to properly handle dragging
   - Made sure the dragging works even during camera movement

The changes allow the user to independently drag the sphere around while still being able to move the camera with WASD keys. The sphere's position is maintained in world space, so it stays where it's placed even as the camera moves around it.